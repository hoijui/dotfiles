" experimental {{{1

" XXX
" nnoremap <silent> o :call <SID>smart_comment_map("o")<CR>
" nnoremap <silent> O :call <SID>smart_comment_map("O")<CR>
"
" function! s:smart_comment_map(key)
"   let line = getline('.')
"   " TODO
"   let mark = "*"
"   let org=&formatoptions
"   if line =~ '^\s*'. substitute(mark, '\([\*\$]\)', '\\\1', 'g')
"     setl formatoptions+=r formatoptions+=o
"   else
"     setl formatoptions-=r formatoptions-=o
"   endif
"   execute 'normal!' a:key
"   let &formatoptions=org
"   startinsert
" endfunction

function! s:filetype_check()
  if !empty(&filetype)
    " if !get(g:, 'syntax_on', 0)
    "   call s:log("syntax enable")
    "   syntax enable
    " endif
    return
  endif
  redir! => fts
  silent filetype
  redir END
  let status = filter(map(split(fts, " "), 'split(v:val, ":")'), '!empty(v:val)')
  call remove(status, 0)
  if len(filter(status, 'v:val[1] == "OFF"')) > 0
    filetype plugin indent on
  endif
endfunction
" MyAutoCmd BufReadPost,BufEnter * call s:filetype_check()

" deprecated {{{1
" plugin {{{1
" NeoBundleLazy 'osyo-manga/vim-over', {'autoload':{
" \ 'commands': ['OverCommandLine'],
" \ 'insert': 1,
" \ }}
" NeoBundleLazy 'mattn/benchvimrc-vim'
" NeoBundleLazy 'tyru/stickykey.vim', {
" \ 'autoload' : {
" \ 'mappings' : [['icsl', '<Plug>(stickykey-']]
" \ }}
" "" NeoBundle 'tomtom/quickfixsigns_vim'
" NeoBundleLazy 't9md/vim-textmanip'
" NeoBundle 'vim-scripts/ShowMarks7'
  " NeoBundleLazy 'editorconfig/editorconfig-vim'
" NeoBundleLazy 'kien/ctrlp.vim'
" doesn't work well
" NeoBundleLazy 'LeafCage/nebula.vim', {'autoload': {
" \ 'commands': ['NebulaPutLazy', 'NebulaPutConfig', 'NebulaYankOptions', 'NebulaPutFromClipboard'],
" \ }}
" conflict with Fugitive
" NeoBundleLazy 'sjl/splice.vim', {'autoload': {
" \ 'commands': [
" \   'SpliceInit', 'SpliceGrid', 'SpliceLoupe',
" \   'SpliceCompare', 'SplicePath', 'SpliceOriginal',
" \   'SpliceOne', 'SpliceTwo', 'SpliceResult',
" \   'SpliceDiff', 'SpliceDiffoff', 'SpliceScroll',
" \   'SpliceLayout', 'SpliceNext', 'SplicePrev',
" \   'SpliceUse', 'SpliceUse1', 'SpliceUse2',
" \ ],
" \ }}
NeoBundleLazy 'thinca/vim-editvar', {'autoload': {
\ 'commands': [{'name': 'Editvar', 'complete': 'var'}],
\ 'unite_sources': ['variable'],
\ }}
NeoBundleLazy 'pekepeke/cascading.vim', {'autoload':{
\ 'commands': ['Cascading'],
\ 'mappings': [['n', '<Plug>(cascading)']]
\ }}
" NeoBundle 'terryma/vim-multiple-cursors'
" NeoBundle 'chrisbra/SudoEdit.vim'
" if s:is_mac
"   if has('gui_running')
"     NeoBundle 'gmarik/sudo-gui.vim'
"   else
"     NeoBundleLazy 'gmarik/sudo-gui.vim'
"   endif
" endif

" NeoBundleLazy 'wesleyche/SrcExpl', {'autoload': {
" \ 'commands': ['SrcExpl', 'SrcExplClose', 'SrcExplToggle',],
" \ }}
" NeoBundle 'abudden/TagHighlight'
" NeoBundle 'motemen/git-vim'
NeoBundle 'int3/vim-extradite'
NeoBundleLazy 'Shougo/vim-vcs', {'autoload': {
\ 'functions': ['vcs#info'],
\ }}
" NeoBundleLazy 'mbadran/headlights'

" unite {{{1
" NeoBundle 'ujihisa/unite-font'
" NeoBundle 'tacroe/unite-alias'
" NeoBundle 'hakobe/unite-script'
" NeoBundle 'mattn/unite-remotefile'
" NeoBundle 'pekepeke/unite-fileline'
" NeoBundle 'sgur/unite-qf'
NeoBundleLazy 'kmnk/vim-unite-giti', { 'autoload' : {
\ 'unite_sources' : ['giti', 'giti/branch', 'giti/config',
\   'giti/log', 'giti/remote', 'giti/status',],
\ }}
NeoBundleLazy 'kmnk/vim-unite-svn', { 'autoload' : {
\ 'unite_sources' : ['svn/status', 'svn/diff', 'svn/blame',
\   ],
\ }}

" macvim {{{1

  " if s:is_mac && has('macvim')
  "   let $RUBY_DLL = "/usr/local/lib/libruby.1.8.dylib"
  "   let $PYTHON_DLL = "/usr/local/lib/libpython2.7.dylib"
  "   if executable('/usr/local/Frameworks/Python.framework/Versions/3.3/Python')
  "     let $PYTHON3_DLL='/usr/local/Frameworks/Python.framework/Versions/3.3/Python'
  "   endif
  " endif

" scroll {{{1
if 1 " {{{4 http://vim-users.jp/2011/04/hack213/

else " {{{4 altanative
  augroup vimrc-scroll-mouse
    autocmd!

    let s:org_scrolloff=-1
    function! s:noscrolloff_leftmouse()
      set eventignore=CursorMoved,CursorMovedI
      if s:org_scrolloff < 0
        let s:org_scrolloff = &scrolloff
      endif
      let &scrolloff = 0
      exe 'normal!' "\<LeftMouse>"
      " let &scrolloff = org_scrolloff
      autocmd CursorMoved * call s:restore_noscrolloff()
      set eventignore=
    endfunction

    function! s:restore_noscrolloff()
      autocmd!
      if s:org_scrolloff < 0
        return
      endif
      let &scrolloff = s:org_scrolloff
      let s:org_scrolloff = -1
    endfunction
    " autocmd CursorMoved * call s:restore_noscrolloff()
    nnoremap <silent> <LeftMouse>       :call <SID>noscrolloff_leftmouse()<CR>
    nnoremap          <2-LeftMouse>     g*
  augroup END
endif "}}}
" vmap              <LeftMouse> <Plug>(visualstar-g*)

" translate maps {{{1
" vnoremap <Leader>tj    :GoogleTranslate ja<CR>
" vnoremap <Leader>tj    :BingTranslate ja<CR>

" mygrep.vim…
"nmap [!space]gg :EGrep<CR>
"nmap [!space]gr :RGrep<CR>
" nnoremap [!space]gg :Grep<CR>
" nnoremap [!space]gr :REGrep<CR>

" plugins ================= {{{1
" NeoBundle 'git://gist.github.com/5457352.git', {
"       \ 'directory' : 'ginger',
"       \ 'script_type' : 'plugin',
"       \ }
" NeoBundle 'pekepeke/golden-ratio'
" NeoBundle 'scrooloose/nerdtree'
" NeoBundle 'scrooloose/nerdcommenter'
" NeoBundle 'vim-scripts/Highlight-UnMatched-Brackets' " incompatible with smartinput
" NeoBundle 'vimtaku/hl_matchit.vim'
" if has('python')
"   NeoBundle 'Valloric/MatchTagAlways'
" else
" endif
NeoBundleLazy 'mklabs/vim-fetch', { 'autoload' : {
      \ 'commands' : [
      \   {'name': 'Fetch', 'complete':'customlist,s:Completion'},
      \   'FetchManage',
      \ ], }}
" NeoBundle 'tpope/vim-endwise'
" NeoBundle 'vim-scripts/YankRing.vim'
" NeoBundle 'maxbrunsfeld/vim-yankstack'
" NeoBundle 'chrismetcalf/vim-yankring'
" NeoBundle 'the-isz/MinYankRing.vim'
" NeoBundle 'Raimondi/delimitMate'
" NeoBundle 'acustodioo/vim-enter-indent'
  " NeoBundleLazy 'Shougo/neocomplcache.vim'
  " NeoBundle 'pekepeke/neocomplcache-rsense.vim', 'neocompleteFeature'

" NeoBundle 'houtsnip/vim-emacscommandline'

" NeoBundle 'ap/vim-css-color'

" NeoBundle 'lukaszb/vim-web-indent'
" NeoBundle 'vim-scripts/IndentAnything'
" NeoBundle 'itspriddle/vim-javascript-indent'
" NeoBundle 'jiangmiao/simple-javascript-indenter'
" NeoBundle 'drslump/vim-syntax-js'
" NeoBundle  'vim-scripts/jQuery'
" NeoBundle 'mmalecki/vim-node.js'
" NeoBundle 'thinca/vim-ft-markdown_fold'

" NeoBundle 'petdance/vim-perl'
"NeoBundleLazyOn FileType cpp 'OmniCppComplete'
" NeoBundleLazyOn FileType php 'oppara/vim-unite-cake'
" NeoBundleLazy 'heavenshell/unite-zf', { 'autoload' : {
"       \ 'unite_sources' : [
"       \   'zf/app', 'zf/controllers', 'zf/models', 'zf/views',
"       \   'zf/helpers', 'zf/configs', 'zf/layouts', 'zf/modules',
"       \   'zf/tests', 'zf/services',
"       \ ],
"       \ }}
" NeoBundle 'heavenshell/unite-sf2', { 'autoload' : {
"       \ 'unite_sources' : [
"       \   'sf2/', 'sf2/app', 'sf2/app', 'sf2/app/config', 'sf2/app/views',
"       \   'sf2/app/web', 'sf2/bundles',
"       \ ],
"       \ }}

" if executable('python')
"   NeoBundle 'mattn/mkdpreview-vim', {
"       \   'build' : {
"       \     'cygwin' : 'chmod u+x static/mkdpreview.py',
"       \     'mac'    : 'chmod u+x static/mkdpreview.py',
"       \     'unix'   : 'chmod u+x static/mkdpreview.py',
"       \   }
"       \ }
" endif
" NeoBundle 'mattn/googletranslate-vim'
" NeoBundle 'mattn/bingtranslate-vim'
" NeoBundle 'Rykka/trans.vim'

" NeoBundleLazy 'kana/vim-textobj-jabraces', {'autoload':{
"       \ 'mappings' : [['ov',
"       \ 'ajb', 'aj(', 'aj)', 'ajr', 'aj[', 'aj]', 'ajB', 'aj{', 'aj}', 'aja', 'aj<', 'aj>', 'ajA',
"       \ 'ajk', 'ajK', 'ajy', 'ajY', 'ajt', 'ajs',
"       \ 'ijb', 'ij(', 'ij)', 'ijr', 'ij[', 'ij]', 'ijB', 'ij{', 'ij}', 'ija', 'ij<', 'ij>', 'ijA',
"       \ 'ijk', 'ijK', 'ijy', 'ijY', 'ijt', 'ijs',
"       \ ]],
"       \ }}
" NeoBundleLazy 'hchbaw/textobj-motionmotion.vim', {'autoload':{
"       \ 'mappings' : [['nvo',
"       \ '<Plug>(textobj-motionmotion-i)', '<Plug>(textobj-motionmotion-a)',
"       \ ]]}}
" NeoBundleLazy 'anyakichi/vim-textobj-xbrackets', {'autoload':{
"       \ 'mappings' : [['vo',
"       \ 'aV(', 'aV)', 'aVb', 'aV{', 'aV}', 'aVB', 'av', 'ax(', 'ax)', 'axb', 'a9', 'a0',
"       \ 'ax<', 'ax[', 'ax{', 'axB', 'axs(', 'axsb', 'axs<', 'axs[', 'axs{', 'axsB',
"       \ 'axs){', 'ay(', 'ayb', 'ay<', 'ay[', 'ay{', 'ayB', 'ays(', 'aysb', 'ays<',
"       \ 'iV(', 'iV)', 'iVb', 'iV{', 'iV}', 'iVB', 'iv', 'ix(', 'ix)', 'ixb', 'i9', 'i0',
"       \ 'ix<', 'ix[', 'ix{', 'ixB', 'ixs(', 'ixsb', 'ixs<', 'ixs[', 'ixs{', 'ixsB',
"       \ 'ixs){', 'iy(', 'iyb', 'iy<', 'iy[', 'iy{', 'iyB', 'iys(', 'iysb', 'iys<',
"       \ 'iys[', 'iys{', 'iysB', 'iys){',
"       \ ]]}}

" NeoBundle 'gorkunov/smartpairs.vim'
" , {'autoload':{
"       \ 'mappings' : [['nx',
"       \ '<Plug>(textobj--i)', '<Plug>(textobj--a)',
"       \ ]]}}

" NeoBundle 'vim-scripts/ruby-matchit'
" NeoBundleLazyOn FileType ruby 'tpope/vim-rbenv'
" NeoBundle 'tpope/vim-rake'
" NeoBundle 'robbevan/Vagrantfile.vim'

" heavy...
" NeoBundleLazyOn FileType html,php 'vim-scripts/indenthtml.vim'
" NeoBundleLazyOn FileType html,php 'vim-scripts/html-improved-indentation'
" NeoBundleLazyOn FileType html,eruby,php 'vim-scripts/closetag.vim'

NeoBundleLazy 'mklabs/grunt.vim', {
      \ 'build': {
      \ 'cygwin': 'npm install',
      \ 'windows': 'npm install',
      \ 'mac': 'npm install',
      \ 'unix': 'npm install',
      \ }, 'autoload': {
      \ 'filetypes': ['javascript', 'coffee'],
      \ }}

NeoBundleLazy 'motemen/hatena-vim', {
      \ 'autoload': {
      \   'commands': ['HatenaEdit', 'HatenaUpdate', 'HatenaUpdateTrivial',
      \     {'name' : 'HatenaEnumUsers', 'complete': 'customlist,HatenaEnumUsers'}
      \ ]}}

" NeoBundleLazy 'coderifous/textobj-word-column.vim', {'autoload':{
"       \ 'mappings' : [['xo', 'ac', 'aC', 'ic', 'iC']]
"       \ }}

" metarw {{{3
" NeoBundle "mattn/vim-metarw"
" NeoBundle "mattn/vim-metarw-gist"
" NeoBundle "mattn/vim-metarw-git"
" NeoBundle "sorah/metarw-simplenote.vim"


" plugin settings {{{1
" git-vim {{{2
" let g:git_no_map_default = 1
" let g:git_command_edit = 'rightbelow vnew'
" nnoremap [!space]gd :<C-u>GitDiff --cached<Enter>
" nnoremap [!space]gD :<C-u>GitDiff<Enter>
" nnoremap [!space]gs :<C-u>GitStatus<Enter>
" nnoremap [!space]gl :<C-u>GitLog<Enter>
" nnoremap [!space]gL :<C-u>GitLog -u \| head -10000<Enter>
" nnoremap [!space]ga :<C-u>GitAdd<Enter>
" nnoremap [!space]gA :<C-u>GitAdd <cfile><Enter>
" nnoremap [!space]gc :<C-u>GitCommit<Enter>
" nnoremap [!space]gC :<C-u>GitCommit --amend<Enter>
" nnoremap [!space]gp :<C-u>Git push

" hl_matchit {{{2
if s:bundle.tap('hl_matchit.vim')
  let g:hl_matchit_enable_on_vim_startup = 0
  let g:hl_matchit_hl_groupname = 'Title'
  let g:hl_matchit_allow_ft_regexp = 'html\|eruby\|eco'
  let s:hl_matchit_running = get(g:, 'hl_matchit_enable_on_vim_startup', 0)
  let s:hl_matchit_last_off_time = 0

  function! s:bundle.tapped.hooks.on_source(bundle)
    function! s:hl_matchit_fire(on)
      if a:on
        call hl_matchit#do_highlight()
        " HiMatchOn
      elseif !a:on
        HiMatchOff
      endif
    endfunction
    if !get(g:, 'hl_matchit_enable_on_vim_startup', 0)
      augroup vimrc-plugin-hl_matchit
        autocmd!
        autocmd CursorHold * call s:hl_matchit_fire(1)
        autocmd CursorMoved * call s:hl_matchit_fire(0)
      augroup END
    endif
  endfunction
  call s:bundle.untap()
endif

" pydiction {{{1
" pydiction {{{2
let g:pydiction_location = '~/.vim/dict/pydiction-complete-dict'

" grep {{{1
nnoremap [!space]g  :Ack<Space>-i<Space>''<Left>
nnoremap [!space]gg :Ack<Space>-i<Space>''<Left>

" unite-greplauncher {{{1
" NeoBundleLazy 'daisuzu/unite-grep_launcher', { 'autoload' : {
"       \ 'unite_sources' : ['grep_launcher'],
"       \ }}
  " unite-grep_launcher {{{3
  if s:bundle.is_installed('unite-grep_launcher')
    if !exists('g:grep_launcher_words')
      let g:grep_launcher_words = {}
    endif
    call extend(g:grep_launcher_words, {
      \ 'TODO' : s:regexp_todo,
      \ })
  endif


" let-modeline {{{1
" NeoBundle 'vim-scripts/let-modeline.vim'
" let-modeline.vim {{{2
if s:bundle.tap('let-modeline.vim')
  function! s:bundle.tapped.hooks.on_source(bundle)
    MyAutoCmd BufEnter * call FirstModeLine()
    " MyAutoCmd BufNewFile * let b:this_is_new_buffer=1
  endfunction
  call s:bundle.untap()
endif


" airline {{{1
" NeoBundle 'bling/vim-airline'

" NeoBundleLazy "osyo-manga/unite-airline_themes", {'autoload':{
"       \ 'unite_sources' : ['airline_themes'],
"       \ }}
" airline {{{2
if s:bundle.tap('vim-airline')
  let g:airline_left_sep='|'
  let g:airline_right_sep='|'
  let g:airline_linecolumn_prefix = ':'
  let g:airline_branch_prefix = 'BR:'
  let g:airline_paste_symbol = '[P]'
  let g:airline_readonly_symbol = '[R]'

  let g:airline_enable_syntastic=0
  " let g:airline_powerline_fonts=0
  let g:airline_enable_branch=1
  let g:airline_detect_modified=1
  let g:airline_detect_paste=1
  let g:airline_detect_iminsert=1
  let g:airline_theme='powerlineish'
  call s:bundle.untap()
endif


" NeoBundleLazy 'Lokaltog/powerline', { 'rtp' : 'powerline/bindings/vim'}
" NeoBundle 'zhaocai/linepower.vim'
" NeoBundleLazy 'Lokaltog/vim-powerline'

" vim-powerline {{{1
" vim-powerline {{{2
if s:bundle.is_installed('vim-powerline')
  if !has('vim_starting') && exists('*Pl#UpdateStatusline')
    call Pl#UpdateStatusline(1)
  endif
endif
" powerline {{{1
" powerline {{{2
if s:bundle.is_installed('powerline')
  let g:unite_force_overwrite_statusline = 0
  " let g:powerline_config_path = expand('~/.vim/powerline')
  let g:powerline_config_overrides = {
        \  "common": {
        \    "dividers": {
        \      "left": {
        \        "hard": " > ",
        \        "soft": "|",
        \      },
        \      "right": {
        \        "hard": " < ",
        \        "soft": " | ",
        \      }
        \    },
        \  },
        \ }
  let g:powerline_theme_overrides__default = {
        \  "segment_data": {
        \    "mode" : {
        \      "args": {
        \        "override": {
        \          "n": "NORMAL",
        \          "v": "VISUAL",
        \          "i": "INSERT",
        \          "R": "REPLACE",
        \          "!": "SHELL",
        \        },
        \      },
        \    },
        \    "branch": {
        \      "before": "BR:",
        \    },
        \    "modified_indicator": {
        \      "args": { "text": "+" },
        \    },
        \    "readonly_indicator": {
        \      "args": { "text": "[R]" },
        \    },
        \    "line_percent": {
        \      "after": "%"
        \    },
        \    "line_current_symbol": {
        \      "contents": "LN",
        \    },
        \  },
        \ }
  if s:bundle.is_installed('linepower.vim')
    if !s:is_win && !isdirectory(expand('~/.config/powerline'))
      call system(printf("cp -r %s ~/.config/powerline",
            \ neobundle#get('linepower.vim').path . "/config" ))
    endif
    " let g:powerline_config_path = neobundle#get('linepower.vim').path . "/config"
    " let g:powerline_config_path = neobundle#get('powerline').path . "/powerline/config_files"
  endif

  if !has('vim_starting') && exists('*PowerlineNew')
    set statusline=%!PowerlineNew()
    call PowerlineNew()
    redraw!
  endif
endif

if !has('vim_starting')
else
  " function! s:powerline_init()
  "   if &diff || &filetype =~# 'gitcommit\|svn\|hgcommit'
  "     " do nothing
  "   elseif !s:is_win && (has('python') || has('python3'))
  "     NeoBundleSource powerline
  "   else
  "     NeoBundleSource vim-powerline
  "   endif
  " endfunction
  " Lazy call s:powerline_init()

endif

" dotnet-complete {{{1
" NeoBundle 'yuratomo/dotnet-complete'
" csharp {{{2
if s:bundle.is_installed('dotnet-complete')
  MyAutoCmd BufNewFile,BufRead *.xaml    setf xml | setl omnifunc=xaml#complete
  MyAutoCmd BufNewFile,BufRead *.cs      setl omnifunc=cs#complete
  MyAutoCmd BufNewFile,BufRead *.cs      setl bexpr=cs#balloon() | setl ballooneval
endif

" others

" tiny-snippets {{{2
" if s:bundle.is_installed('unite.vim')
"   let s:unite_action_file_insert = {} " {{{3
"   function! s:unite_action_file_insert.func(candicate)
"     "echo a:candicate
"     let l:path = a:candicate.word
"     if isdirectory(l:path)
"       call unite#do_action('narrow')
"     elseif filereadable(l:path)
"       let linesread=line('$')
"       let l:old_cpoptions=&cpoptions
"       setlocal cpoptions-=a
"       :execute 'read '.l:path
"       let &cpoptions = l:old_cpoptions
"       let linesread=line('$')-linesread-1
"       if linesread >= 0
"         silent exe 'normal! ='.linesread.'+'
"       endif
"     endif
"   endfunction
"   call unite#custom_action('file', 'insert_file', s:unite_action_file_insert)
"   unlet! s:unite_action_file_insert
" endif

" }}}

" neocomplcache {{{1
  " let g:neocomplcache_enable_auto_delimiter               = 1
  " let g:neocomplcache_plugin_completion_length     = {
  " let g:neocomplcache_auto_completion_start_length        = 2
  " let g:neocomplcache_manual_completion_start_length      = 1
  " let g:neocomplcache_min_keyword_length                  = 3
  " let g:neocomplcache_ignore_case                         = 0
  " \ 'snipMate_complete' : 1,
  " \ 'buffer_complete'   : 1,
  " \ 'include_complete'  : 2,
  " \ 'syntax_complete'   : 2,
  " \ 'filename_complete' : 2,
  " \ 'keyword_complete'  : 2,
  " \ 'omni_complete'     : 1,
  " \ }
  " inoremap <expr><CR>  neocomplcache#smart_close_popup() . "\<CR>"
  " inoremap <silent> <CR> <C-R>=neocomplcache#smart_close_popup()<CR><CR>
  " endwise
  " inoremap <silent> <cr> <c-r>=EnterIndent()<cr>
  " if s:bundle.is_installed('vim-indent_cr')
    " Lazy inoremap <silent><expr> <CR> (pumvisible()?neocomplcache#smart_close_popup():"")
    "       \ ."\<C-r>=indent_cr#enter()\<CR>\<C-r>=endwize#crend()\<CR>"
  " else
    " Lazy inoremap <silent><expr> <CR> (pumvisible()?neocomplcache#smart_close_popup():"")
    "       \ ."\<CR>\<C-r>=endwize#crend()\<CR>"
  " endif

  " <TAB>: completion.
  " inoremap <expr><TAB>  pumvisible() ? "\<C-n>" : "\<TAB>"
    " inoremap <expr> <C-h>  neocomplcache#smart_close_popup()
    "       \ . eval(smartinput#sid().'_trigger_or_fallback("\<BS>", "\<C-h>")')
    " inoremap <expr> <BS>   neocomplcache#smart_close_popup()
    "       \ .eval(smartinput#sid().'_trigger_or_fallback("\<BS>", "\<BS>")')

" neocomplete {{{1
  " inoremap <expr><CR>  neocomplete#smart_close_popup() . "\<CR>"
  " inoremap <silent> <CR> <C-R>=neocomplete#smart_close_popup()<CR><CR>
  " endwise
  " inoremap <silent> <cr> <c-r>=EnterIndent()<cr>
  " if s:bundle.is_installed('vim-enter-indent')
  "   Lazy inoremap <silent><expr> <CR> (pumvisible()?neocomplete#smart_close_popup():"")."\<C-r>=indent_cr#enter()\<CR>\<C-r>=endwize#crend()\<CR>"
  " else
  "   Lazy inoremap <silent><expr> <CR> (pumvisible()?neocomplete#smart_close_popup():"")."\<CR>\<C-r>=endwize#crend()\<CR>"
  " endif
  " <TAB>: completion.
  " inoremap <expr><TAB>  pumvisible() ? "\<C-n>" : "\<TAB>"

    " inoremap <expr> <C-h>  neocomplete#smart_close_popup()
    "       \ . eval(smartinput#sid().'_trigger_or_fallback("\<BS>", "\<C-h>")')
    " inoremap <expr> <BS>   neocomplete#smart_close_popup()
    "       \ .eval(smartinput#sid().'_trigger_or_fallback("\<BS>", "\<BS>")')

" vimfiler {{{1
      if exists('b:vimfiler.context.explorer') && b:vimfiler.context.explorer "{{{4
        " nmap <silent><buffer> L <Plug>(vimfiler_smart_l)
        " nmap <silent><buffer> E :call <SID>vimfiler_tabopen()<CR>
        " " smart_h ができない…ｼｮﾎﾞﾝﾇ(´Д｀)
        " " nmap <silent><buffer> H <Plug>(vimfiler_smart_h)
        " if exists('g:scrolloff')
        "   nnoremap <silent><buffer> <LeftMouse>       <Esc>:set eventignore=all<CR><LeftMouse>:<C-u>execute "normal \<Plug>(vimfiler_expand_tree)"<CR>:set eventignore=<CR>
        "   nnoremap <silent><buffer> <2-LeftMouse>     <Esc>:set eventignore=all<CR><LeftMouse>:<C-u>execute "normal \<Plug>(vimfiler_execute_system_associated)"<CR>:set eventignore=<CR>
        " else
        "   nnoremap <silent><buffer> <LeftMouse> :call <SID>noscrolloff_leftmouse()<CR>:<C-u>execute "normal \<Plug>(vimfiler_expand_tree)"<CR>
        "   nnoremap <silent><buffer> <2-LeftMouse> :call <SID>noscrolloff_leftmouse()<CR>:<C-u>execute "normal \<Plug>(vimfiler_execute_system_associated)"<CR>
        " endif

" other settings {{{1
" chm launcher {{{2
if exists('g:my_chm_dir') && (s:is_win || (!s:is_win && !empty(g:my_chm_command)))
  command! -nargs=1 -complete=customlist,my#chm#complete
        \ Chm call my#chm#open("<args>")
  LCAlias Chm
endif

if exists('g:my_cheatsheets_dir')
  command! -nargs=1 -complete=customlist,my#cheatsheet#complete
        \ CheatSheet call my#cheatsheet#open("<args>")
  LCAlias CheatSheet
endif


" __END__ {{{1
