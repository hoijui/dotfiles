" experimental {{{1

" XXX
" nnoremap <silent> o :call <SID>smart_comment_map("o")<CR>
" nnoremap <silent> O :call <SID>smart_comment_map("O")<CR>
"
" function! s:smart_comment_map(key)
"   let line = getline('.')
"   " TODO
"   let mark = "*"
"   let org=&formatoptions
"   if line =~ '^\s*'. substitute(mark, '\([\*\$]\)', '\\\1', 'g')
"     setl formatoptions+=r formatoptions+=o
"   else
"     setl formatoptions-=r formatoptions-=o
"   endif
"   execute 'normal!' a:key
"   let &formatoptions=org
"   startinsert
" endfunction

" deprecated {{{1
" macvim {{{1

  " if s:is_mac && has('macvim')
  "   let $RUBY_DLL = "/usr/local/lib/libruby.1.8.dylib"
  "   let $PYTHON_DLL = "/usr/local/lib/libpython2.7.dylib"
  "   if executable('/usr/local/Frameworks/Python.framework/Versions/3.3/Python')
  "     let $PYTHON3_DLL='/usr/local/Frameworks/Python.framework/Versions/3.3/Python'
  "   endif
  " endif

" scroll {{{1
if 1 " {{{4 http://vim-users.jp/2011/04/hack213/

else " {{{4 altanative
  augroup vimrc-scroll-mouse
    autocmd!

    let s:org_scrolloff=-1
    function! s:noscrolloff_leftmouse()
      set eventignore=CursorMoved,CursorMovedI
      if s:org_scrolloff < 0
        let s:org_scrolloff = &scrolloff
      endif
      let &scrolloff = 0
      exe 'normal!' "\<LeftMouse>"
      " let &scrolloff = org_scrolloff
      autocmd CursorMoved * call s:restore_noscrolloff()
      set eventignore=
    endfunction

    function! s:restore_noscrolloff()
      autocmd!
      if s:org_scrolloff < 0
        return
      endif
      let &scrolloff = s:org_scrolloff
      let s:org_scrolloff = -1
    endfunction
    " autocmd CursorMoved * call s:restore_noscrolloff()
    nnoremap <silent> <LeftMouse>       :call <SID>noscrolloff_leftmouse()<CR>
    nnoremap          <2-LeftMouse>     g*
  augroup END
endif "}}}
" vmap              <LeftMouse> <Plug>(visualstar-g*)

" translate maps {{{1
" vnoremap <Leader>tj    :GoogleTranslate ja<CR>
" vnoremap <Leader>tj    :BingTranslate ja<CR>

" mygrep.vimâ€¦
"nmap [!space]gg :EGrep<CR>
"nmap [!space]gr :RGrep<CR>
" nnoremap [!space]gg :Grep<CR>
" nnoremap [!space]gr :REGrep<CR>

" plugins ================= {{{1
" NeoBundle 'git://gist.github.com/5457352.git', {
"       \ 'directory' : 'ginger',
"       \ 'script_type' : 'plugin',
"       \ }
" NeoBundle 'pekepeke/golden-ratio'
" NeoBundle 'scrooloose/nerdtree'
" NeoBundle 'scrooloose/nerdcommenter'
NeoBundleLazy 'mklabs/vim-fetch', { 'autoload' : {
      \ 'commands' : [
      \   {'name': 'Fetch', 'complete':'customlist,s:Completion'},
      \   'FetchManage',
      \ ], }}

" NeoBundle 'petdance/vim-perl'
"NeoBundleLazyOn FileType cpp 'OmniCppComplete'
" NeoBundleLazyOn FileType php 'oppara/vim-unite-cake'
" NeoBundleLazy 'heavenshell/unite-zf', { 'autoload' : {
"       \ 'unite_sources' : [
"       \   'zf/app', 'zf/controllers', 'zf/models', 'zf/views',
"       \   'zf/helpers', 'zf/configs', 'zf/layouts', 'zf/modules',
"       \   'zf/tests', 'zf/services',
"       \ ],
"       \ }}
" NeoBundle 'heavenshell/unite-sf2', { 'autoload' : {
"       \ 'unite_sources' : [
"       \   'sf2/', 'sf2/app', 'sf2/app', 'sf2/app/config', 'sf2/app/views',
"       \   'sf2/app/web', 'sf2/bundles',
"       \ ],
"       \ }}

" if executable('python')
"   NeoBundle 'mattn/mkdpreview-vim', {
"       \   'build' : {
"       \     'cygwin' : 'chmod u+x static/mkdpreview.py',
"       \     'mac'    : 'chmod u+x static/mkdpreview.py',
"       \     'unix'   : 'chmod u+x static/mkdpreview.py',
"       \   }
"       \ }
" endif
" NeoBundle 'mattn/googletranslate-vim'
" NeoBundle 'mattn/bingtranslate-vim'
" NeoBundle 'Rykka/trans.vim'

" NeoBundleLazy 'kana/vim-textobj-jabraces', {'autoload':{
"       \ 'mappings' : [['ov',
"       \ 'ajb', 'aj(', 'aj)', 'ajr', 'aj[', 'aj]', 'ajB', 'aj{', 'aj}', 'aja', 'aj<', 'aj>', 'ajA',
"       \ 'ajk', 'ajK', 'ajy', 'ajY', 'ajt', 'ajs',
"       \ 'ijb', 'ij(', 'ij)', 'ijr', 'ij[', 'ij]', 'ijB', 'ij{', 'ij}', 'ija', 'ij<', 'ij>', 'ijA',
"       \ 'ijk', 'ijK', 'ijy', 'ijY', 'ijt', 'ijs',
"       \ ]],
"       \ }}
" NeoBundleLazy 'hchbaw/textobj-motionmotion.vim', {'autoload':{
"       \ 'mappings' : [['nvo',
"       \ '<Plug>(textobj-motionmotion-i)', '<Plug>(textobj-motionmotion-a)',
"       \ ]]}}
" NeoBundleLazy 'anyakichi/vim-textobj-xbrackets', {'autoload':{
"       \ 'mappings' : [['vo',
"       \ 'aV(', 'aV)', 'aVb', 'aV{', 'aV}', 'aVB', 'av', 'ax(', 'ax)', 'axb', 'a9', 'a0',
"       \ 'ax<', 'ax[', 'ax{', 'axB', 'axs(', 'axsb', 'axs<', 'axs[', 'axs{', 'axsB',
"       \ 'axs){', 'ay(', 'ayb', 'ay<', 'ay[', 'ay{', 'ayB', 'ays(', 'aysb', 'ays<',
"       \ 'iV(', 'iV)', 'iVb', 'iV{', 'iV}', 'iVB', 'iv', 'ix(', 'ix)', 'ixb', 'i9', 'i0',
"       \ 'ix<', 'ix[', 'ix{', 'ixB', 'ixs(', 'ixsb', 'ixs<', 'ixs[', 'ixs{', 'ixsB',
"       \ 'ixs){', 'iy(', 'iyb', 'iy<', 'iy[', 'iy{', 'iyB', 'iys(', 'iysb', 'iys<',
"       \ 'iys[', 'iys{', 'iysB', 'iys){',
"       \ ]]}}

" NeoBundle 'gorkunov/smartpairs.vim'
" , {'autoload':{
"       \ 'mappings' : [['nx',
"       \ '<Plug>(textobj--i)', '<Plug>(textobj--a)',
"       \ ]]}}

" metarw {{{3
" NeoBundle "mattn/vim-metarw"
" NeoBundle "mattn/vim-metarw-gist"
" NeoBundle "mattn/vim-metarw-git"
" NeoBundle "sorah/metarw-simplenote.vim"

" pydiction {{{1
" pydiction {{{2
let g:pydiction_location = '~/.vim/dict/pydiction-complete-dict'

" unite-greplauncher {{{1
" NeoBundleLazy 'daisuzu/unite-grep_launcher', { 'autoload' : {
"       \ 'unite_sources' : ['grep_launcher'],
"       \ }}
  " unite-grep_launcher {{{3
  if s:bundle.is_installed('unite-grep_launcher')
    if !exists('g:grep_launcher_words')
      let g:grep_launcher_words = {}
    endif
    call extend(g:grep_launcher_words, {
      \ 'TODO' : s:regexp_todo,
      \ })
  endif


" let-modeline {{{1
" NeoBundle 'vim-scripts/let-modeline.vim'
" let-modeline.vim {{{2
if s:bundle.tap('let-modeline.vim')
  function! s:bundle.tapped.hooks.on_source(bundle)
    MyAutoCmd BufEnter * call FirstModeLine()
    " MyAutoCmd BufNewFile * let b:this_is_new_buffer=1
  endfunction
  call s:bundle.untap()
endif


" airline {{{1
" NeoBundle 'bling/vim-airline'

" NeoBundleLazy "osyo-manga/unite-airline_themes", {'autoload':{
"       \ 'unite_sources' : ['airline_themes'],
"       \ }}
" airline {{{2
if s:bundle.tap('vim-airline')
  let g:airline_left_sep='|'
  let g:airline_right_sep='|'
  let g:airline_linecolumn_prefix = ':'
  let g:airline_branch_prefix = 'BR:'
  let g:airline_paste_symbol = '[P]'
  let g:airline_readonly_symbol = '[R]'

  let g:airline_enable_syntastic=0
  " let g:airline_powerline_fonts=0
  let g:airline_enable_branch=1
  let g:airline_detect_modified=1
  let g:airline_detect_paste=1
  let g:airline_detect_iminsert=1
  let g:airline_theme='powerlineish'
  call s:bundle.untap()
endif


" NeoBundleLazy 'Lokaltog/powerline', { 'rtp' : 'powerline/bindings/vim'}
" NeoBundle 'zhaocai/linepower.vim'
" NeoBundleLazy 'Lokaltog/vim-powerline'

" vim-powerline {{{1
" vim-powerline {{{2
if s:bundle.is_installed('vim-powerline')
  if !has('vim_starting') && exists('*Pl#UpdateStatusline')
    call Pl#UpdateStatusline(1)
  endif
endif
" powerline {{{1
" powerline {{{2
if s:bundle.is_installed('powerline')
  let g:unite_force_overwrite_statusline = 0
  " let g:powerline_config_path = expand('~/.vim/powerline')
  let g:powerline_config_overrides = {
        \  "common": {
        \    "dividers": {
        \      "left": {
        \        "hard": " > ",
        \        "soft": "|",
        \      },
        \      "right": {
        \        "hard": " < ",
        \        "soft": " | ",
        \      }
        \    },
        \  },
        \ }
  let g:powerline_theme_overrides__default = {
        \  "segment_data": {
        \    "mode" : {
        \      "args": {
        \        "override": {
        \          "n": "NORMAL",
        \          "v": "VISUAL",
        \          "i": "INSERT",
        \          "R": "REPLACE",
        \          "!": "SHELL",
        \        },
        \      },
        \    },
        \    "branch": {
        \      "before": "BR:",
        \    },
        \    "modified_indicator": {
        \      "args": { "text": "+" },
        \    },
        \    "readonly_indicator": {
        \      "args": { "text": "[R]" },
        \    },
        \    "line_percent": {
        \      "after": "%"
        \    },
        \    "line_current_symbol": {
        \      "contents": "LN",
        \    },
        \  },
        \ }
  if s:bundle.is_installed('linepower.vim')
    if !s:is_win && !isdirectory(expand('~/.config/powerline'))
      call system(printf("cp -r %s ~/.config/powerline",
            \ neobundle#get('linepower.vim').path . "/config" ))
    endif
    " let g:powerline_config_path = neobundle#get('linepower.vim').path . "/config"
    " let g:powerline_config_path = neobundle#get('powerline').path . "/powerline/config_files"
  endif

  if !has('vim_starting') && exists('*PowerlineNew')
    set statusline=%!PowerlineNew()
    call PowerlineNew()
    redraw!
  endif
endif

if !has('vim_starting')
else
  " function! s:powerline_init()
  "   if &diff || &filetype =~# 'gitcommit\|svn\|hgcommit'
  "     " do nothing
  "   elseif !s:is_win && (has('python') || has('python3'))
  "     NeoBundleSource powerline
  "   else
  "     NeoBundleSource vim-powerline
  "   endif
  " endfunction
  " Lazy call s:powerline_init()

endif

" dotnet-complete {{{1
" NeoBundle 'yuratomo/dotnet-complete'
" csharp {{{2
if s:bundle.is_installed('dotnet-complete')
  MyAutoCmd BufNewFile,BufRead *.xaml    setf xml | setl omnifunc=xaml#complete
  MyAutoCmd BufNewFile,BufRead *.cs      setl omnifunc=cs#complete
  MyAutoCmd BufNewFile,BufRead *.cs      setl bexpr=cs#balloon() | setl ballooneval
endif

" others

" tiny-snippets {{{2
" if s:bundle.is_installed('unite.vim')
"   let s:unite_action_file_insert = {} " {{{3
"   function! s:unite_action_file_insert.func(candicate)
"     "echo a:candicate
"     let l:path = a:candicate.word
"     if isdirectory(l:path)
"       call unite#do_action('narrow')
"     elseif filereadable(l:path)
"       let linesread=line('$')
"       let l:old_cpoptions=&cpoptions
"       setlocal cpoptions-=a
"       :execute 'read '.l:path
"       let &cpoptions = l:old_cpoptions
"       let linesread=line('$')-linesread-1
"       if linesread >= 0
"         silent exe 'normal! ='.linesread.'+'
"       endif
"     endif
"   endfunction
"   call unite#custom_action('file', 'insert_file', s:unite_action_file_insert)
"   unlet! s:unite_action_file_insert
" endif

" }}}

" __END__ {{{1
